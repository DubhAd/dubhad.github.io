---
layout: post
title: Presence detection, the final countdown?
date: '2019-10-27T06:30:00.000Z'
author: Tinkerer
tags:
- monitor
- home assistant
- presence detection
modified_time: '2019-11-03T08:29:40.514Z'
---

The <a href="https://blog.ceard.tech/2019/03/presence-detection-are-we-nearly-there.html">last time</a> I said that I didn't think there was more I could do. I was wrong.  My use of <a href="https://github.com/andrewjfreyer/monitor">monitor</a> hasn't changed, and I'll leave the config for that below.  <br /><h2>Changed behaviour</h2>Now I've changed the automations so that the majority wins for departure, rather than requiring everything to show <kbd>not_home</kbd>. This makes for faster departures, and avoids problems when something goes wrong with one of the device trackers - one of the monitor nodes sometimes freezes. <p>These work by the magic of a wonderful template somebody else wrote on the Discord server: <P><pre>{{ "{{" }} dict((states|selectattr('entity_id', 'in', state_attr('group.person_person1', 'entity_id'))|list)|groupby('state'))['home']|count }}</pre>This returns the number of entities in that group that are in the state <kbd>home</kbd>.  <P>I'm now using the individual devices in the triggers, so that the automation is run for the change of state on each device, rather than only when the group changes state. This has made things more responsive.  <P>The MQTT device tracker is used purely for the <A HREF="https://www.home-assistant.io/integrations/person">person</A>integration. It serves no other purpose.  <P>As always, these can be found <a href="https://github.com/DubhAd/Home-AssistantConfig">on my GitHub</a>.  <br /><h3>Automations and scripts</h3><b>Departure automation</b><br /><pre>alias: 'person1 away'<br />initial_state: 'on'<br />trigger:<br />  - platform: state<br />    entity_id: <br />      - device_tracker.person1_phone_wifi<br />      - device_tracker.person1_bt_mobile<br />      - device_tracker.person1_bt_front_mobile<br />    to: 'not_home'<br />  - platform: homeassistant<br />    event: start<br />condition:<br />  # As long as at least two trackers mark as away, they're away<br />  - condition: numeric_state<br />    entity_id: group.person_person1<br />    below: 2<br />    value_template: "{{ "{{" }} dict((states|selectattr('entity_id', 'in', state_attr('group.person_person1', 'entity_id'))|list)|groupby('state'))['home']|count }}"<br />  # An exit door recently opened or closed - I can likely drop this to 300 (5 minutes)<br />  - condition: template<br />    value_template: "{{ "{{" }} (as_timestamp(now()) - as_timestamp(states.binary_sensor.pi3_front_door_sensor.last_updated)) | int &lt; 600 }}"<br />action:<br />  - service: script.person1_away</pre><b>Departure script</b><br /><pre>alias: person1 away<br />sequence:<br />  - service: input_boolean.turn_off<br />    entity_id: input_boolean.person1_home<br />  - service: mqtt.publish<br />    data:<br />      topic: location/person1<br />      payload: 'not_home'<br /></pre><br /><b>Arrival automation</b><br /><pre>initial_state: 'on'<br />alias: 'person1 home'<br />trigger:<br />  - platform: state<br />    entity_id: <br />      - device_tracker.person1_phone_wifi<br />      - device_tracker.person1_bt_mobile<br />      - device_tracker.person1_bt_front_mobile<br />    to: 'home'<br />  - platform: homeassistant<br />    event: start<br />condition:<br />  - condition: numeric_state<br />    entity_id: group.person_person1<br />    above: 0<br />    value_template: "{{ "{{" }} dict((states|selectattr('entity_id', 'in', state_attr('group.person_person1', 'entity_id'))|list)|groupby('state'))['home']|count }}"<br />action:<br />  - service: script.person1_home</pre><b>Arrival script</b><br /><pre>alias: person1 home<br />sequence:<br />  - service: input_boolean.turn_on<br />    entity_id: input_boolean.person1_home<br />  - service: mqtt.publish<br />    data:<br />      topic: location/person1<br />      payload: 'home'</pre><h2>Monitor</h2><h3>Behaviour preferences</h3><pre>#MAX RETRY ATTEMPTS FOR ARRIVAL<br />PREF_ARRIVAL_SCAN_ATTEMPTS=2<br /><br />#MAX RETRY ATTEMPTS FOR DEPART<br />PREF_DEPART_SCAN_ATTEMPTS=2<br /><br />#SECONDS UNTIL A BEACON IS CONSIDERED EXPIRED<br />PREF_BEACON_EXPIRATION=240<br /><br />#MINIMUM TIME BEWTEEN THE SAME TYPE OF SCAN (ARRIVE SCAN, DEPART SCAN)<br />PREF_MINIMUM_TIME_BETWEEN_SCANS=15<br /><br />#ARRIVE TRIGGER FILTER(S)<br />PREF_PASS_FILTER_ADV_FLAGS_ARRIVE=".*"<br />PREF_PASS_FILTER_MANUFACTURER_ARRIVE="Google|HTC Corporation|LG Electronics|Chipolo"<br /><br />PREF_FAIL_FILTER_ADV_FLAGS_ARRIVE="NONE"<br />PREF_FAIL_FILTER_MANUFACTURER_ARRIVE="NONE"<br /><br />PREF_RSSI_IGNORE_BELOW=-95<br />PREF_DEVICE_TRACKER_REPORT=true<br /></pre><h3>Command line flags</h3>I'm using <kbd>-x -b -tdr</kbd> as the flags, and these mean:<br /><ul><li>-x -&nbsp;retain mqtt status messages</li><li>-b - report bluetooth beacons</li><li>-tdr - only performs a <i>departure</i>&nbsp;scan when a message is published to the MQTT topic, and notifies other instances when it does a scan</li></ul><br /><br /><br />